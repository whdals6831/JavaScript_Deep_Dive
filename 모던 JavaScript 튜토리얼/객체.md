- 객체형은 원시형과 달리 다양한 데이터를 담을 수 있습니다. 키로 구분된 데이터 집합이나 복잡한 개체(entity)를 저장할 수 있죠.
- 객체는 중괄호 {…}를 이용해 만들 수 있습니다. 중괄호 안에는 ‘키(key): 값(value)’ 쌍으로 구성된 프로퍼티(property) 를 여러 개 넣을 수 있는데, **키엔 문자형, 값엔 모든 자료형이 허용**됩니다. 프로퍼티 키는 ‘프로퍼티 이름’ 이라고도 부릅니다.

- 서랍장을 상상하면 객체를 이해하기 쉽습니다. 서랍장 안 파일은 프로퍼티, 파일 각각에 붙어있는 이름표는 객체의 키라고 생각하시면 됩니다. 복잡한 서랍장 안에서 이름표를 보고 원하는 파일을 쉽게 찾을 수 있듯이, 객체에선 키를 이용해 프로퍼티를 쉽게 찾을 수 있습니다. 추가나 삭제도 마찬가지입니다.
- 빈 객체(빈 서랍장)를 만드는 방법은 두 가지가 있습니다.

    ```jsx
    let user = new Object(); // '객체 생성자' 문법
    let user = {};  // '객체 리터럴' 문법
    ```

> **리터럴과 프로퍼티**

- 중괄호 {...} 안에는 ‘키: 값’ 쌍으로 구성된 프로퍼티가 들어갑니다.

```jsx
let user = {     // 객체
  name: "John",  // 키: "name",  값: "John"
  age: 30        // 키: "age", 값: 30
};
```

- '콜론(:)'을 기준으로 왼쪽엔 키가, 오른쪽엔 값이 위치합니다. 프로퍼티 키는 프로퍼티 ‘이름’ 혹은 '식별자’라고도 부릅니다.

```jsx
// 프로퍼티 값 얻기
alert( user.name ); // John
alert( user.age ); // 30

// delete 연산자를 사용하면 프로퍼티를 삭제할 수 있습니다.
delete user.age;
```

- 여러 단어를 조합해 프로퍼티 이름을 만든 경우엔 프로퍼티 이름을 따옴표로 묶어줘야 합니다.

```jsx
let user = {
  name: "John",
  age: 30,
  "likes birds": true  // 복수의 단어는 따옴표로 묶어야 합니다.
};
```

⚠️  상수 객체는 수정될 수 있습니다.

주의하세요. const로 선언된 객체는 수정될 수 있습니다.

예시 :

```jsx
const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete
```

- `(*)`로 표시한 줄에서 오류를 일으키는 것처럼 보일 수 있지만 그렇지 않습니다. `const`는 `user`의 값을 고정하지만, 그 내용은 고정하지 않습니다.
- `const`는 `user=...`를 전체적으로 설정하려고 할 때만 오류가 발생합니다.

> **대괄호 표기법**

- 여러 단어를 조합해 프로퍼티 키를 만든 경우엔, 점 표기법을 사용해 프로퍼티 값을 읽을 수 없습니다.

```jsx
// 문법 에러가 발생합니다.
user.likes birds = true
```

- 키가 유효한 변수 식별자가 아닌 경우엔 점 표기법 대신에 '대괄호 표기법(square bracket notation)'이라 불리는 방법을 사용할 수 있습니다. 대괄호 표기법은 키에 어떤 문자열이 있던지 상관없이 동작합니다.

```jsx
let user = {};

// set
user["likes birds"] = true;

// get
alert(user["likes birds"]); // true

// delete
delete user["likes birds"];
```

- 대괄호 표기법을 사용하면 아래 예시에서 변수를 키로 사용한 것과 같이 문자열뿐만 아니라 모든 표현식의 평가 결과를 프로퍼티 키로 사용할 수 있습니다.

```jsx
let key = "likes birds";

// user["likes birds"] = true; 와 같습니다.
user[key] = true;
```

- 변수 key는 런타임에 평가되기 때문에 사용자 입력값 변경 등에 따라 값이 변경될 수 있습니다. 어떤 경우든, 평가가 끝난 이후의 결과가 프로퍼티 키로 사용됩니다. 이를 응용하면 코드를 유연하게 작성할 수 있습니다.

    예시:

    ```jsx
    let user = {
      name: "John",
      age: 30
    };

    let key = prompt("사용자의 어떤 정보를 얻고 싶으신가요?", "name");

    // 변수로 접근
    alert( user[key] ); // John (프롬프트 창에 "name"을 입력한 경우)
    ```

    - 그런데 점 표기법은 이런 방식이 불가능합니다.

    ```jsx
    let user = {
      name: "John",
      age: 30
    };

    let key = "name";
    alert( user.key ) // undefined
    ```

> **계산된 프로퍼티**

- 객체를 만들 때 객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여 있는 경우, 이를 계산된 프로퍼티(computed property) 라고 부릅니다.

    예시:

    ```jsx
    let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

    let bag = {
      [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아 옵니다.
    };

    alert( bag.apple ); // fruit에 "apple"이 할당되었다면, 5가 출력됩니다.
    ```

    - 위 예시에서 [fruit]는 프로퍼티 이름을 변수 fruit에서 가져오겠다는 것을 의미합니다.
    - 아래 예시는 위 예시와 동일하게 동작합니다.

    ```jsx
    let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
    let bag = {};

    // 변수 fruit을 사용해 프로퍼티 이름을 만들었습니다.
    bag[fruit] = 5;
    ```

- 대괄호 표기법은 프로퍼티 이름과 값의 제약을 없애주기 때문에 점 표기법보다 훨씬 강력합니다. 그런데 작성하기 번거롭다는 단점이 있습니다.
- 이런 이유로 프로퍼티 이름이 확정된 상황이고, 단순한 이름이라면 처음엔 점 표기법을 사용하다가 뭔가 복잡한 상황이 발생했을 때 대괄호 표기법으로 바꾸는 경우가 많습니다.

> **단축 프로퍼티**

- 실무에선 프로퍼티 값을 기존 변수에서 받아와 사용하는 경우가 종종 있습니다.

```jsx
function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...등등
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
```

- 위 예시의 프로퍼티들은 이름과 값이 변수의 이름과 동일하네요. 이렇게 변수를 사용해 프로퍼티를 만드는 경우는 아주 흔한데, 프로퍼티 값 단축 구문(property value shorthand) 을 사용하면 코드를 짧게 줄일 수 있습니다.

```jsx
function makeUser(name, age) {
  return {
    name, // name: name 과 같음
    age,  // age: age 와 같음
    // ...
  };
}
```

> **프로퍼티 이름의 제약사항**

- 아시다시피 변수 이름(키)엔 ‘for’, ‘let’, ‘return’ 같은 예약어를 사용하면 안됩니다.
- 그런데 객체 프로퍼티엔 이런 제약이 없습니다.

```jsx
// 예약어를 키로 사용해도 괜찮습니다.
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
```

- 문자형이나 심볼형에 속하지 않은 값은 문자열로 자동 형 변환됩니다.
- 예시를 살펴봅시다. 키에 숫자 0을 넣으면 문자열 "0"으로 자동변환됩니다.

```jsx
let obj = {
  0: "test" // "0": "test"와 동일합니다.
};

// 숫자 0은 문자열 "0"으로 변환되기 때문에 두 얼럿 창은 같은 프로퍼티에 접근합니다,
alert( obj["0"] ); // test
alert( obj[0] ); // test (동일한 프로퍼티)
```

> **‘in’ 연산자로 프로퍼티 존재 여부 확인하기**

- 자바스크립트 객체의 중요한 특징 중 하나는 다른 언어와는 달리, 존재하지 않는 프로퍼티에 접근하려 해도 에러가 발생하지 않고 undefined를 반환한다는 것입니다.
- 이런 특징을 응용하면 프로퍼티 존재 여부를 쉽게 확인할 수 있습니다.

```jsx
let user = {};

alert( user.noSuchProperty === undefined ); // true는 '프로퍼티가 존재하지 않음'을 의미합니다.
```

- 이렇게 undefined와 비교하는 것 이외에도 연산자 in을 사용하면 프로퍼티 존재 여부를 확인할 수 있습니다.

```jsx
let user = { name: "John", age: 30 };

alert( "age" in user ); // user.age가 존재하므로 true가 출력됩니다.
alert( "blabla" in user ); // user.blabla는 존재하지 않기 때문에 false가 출력됩니다.
```

- in 왼쪽엔 반드시 프로퍼티 이름이 와야 합니다. **프로퍼티 이름은 보통 따옴표로 감싼 문자열**입니다.

> **‘for…in’ 반복문**

- for..in 반복문을 사용하면 객체의 모든 키를 순회할 수 있습니다. for..in은 앞서 학습했던 for(;;) 반복문과는 완전히 다릅니다.

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // 키
  alert( key );  // name, age, isAdmin
  // 키에 해당하는 값
  alert( user[key] ); // John, 30, true
}
```

> **객체 정렬 방식**

- 객체와 객체 프로퍼티를 다루다 보면 "프로퍼티엔 순서가 있을까?"라는 의문이 생기기 마련입니다. 반복문은 프로퍼티를 추가한 순서대로 실행될지, 그리고 이 순서는 항상 동일할지 궁금해지죠.
- 답은 간단합니다. 객체는 '특별한 방식으로 정렬’됩니다. 정수 프로퍼티(integer property)는 자동으로 정렬되고, 그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬됩니다. 자세한 내용은 예제를 통해 살펴봅시다.

```jsx
let codes = {
  "49": "독일",
  "41": "스위스",
  "44": "영국",
  // ..,
  "1": "미국"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
```

- 위 예시에서 49(독일 나라 번호)를 가장 위에 출력되도록 하려면 나라 번호가 정수로 취급되지 않도록 속임수를 쓰면 됩니다. 각 나라 번호 앞에 "+"를 붙여봅시다.

    ```jsx
    let codes = {
      "+49": "독일",
      "+41": "스위스",
      "+44": "영국",
      // ..,
      "+1": "미국"
    };

    for (let code in codes) {
      alert( +code ); // 49, 41, 44, 1
    }
    ```