- 자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원합니다.
    1. 일반적인 숫자는 '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 IEEE-754에 저장됩니다. 튜토리얼 전체에서 이 형식을 사용하여 숫자를 표현할 예정입니다.
    2. 임의의 길이를 가진 정수는 BigInt 숫자로 나타낼 수 있습니다. 일반적인 숫자는 253이상이거나 -253이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌습니다. BigInt는 아주 특별한 경우에만 사용되므로, 별도의 챕터 BigInt에서 자세한 내용을 다루겠습니다.

> **숫자를 입력하는 다양한 방법**

- 10억을 입력해야 한다고 상상해 봅니다. 가장 분명한 방법은 아래와 같이 직접 10억(one billion)을 써주는 것입니다.

```jsx
let billion = 1000000000;
```

- 그런데 이렇게 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에, 실제로는 이런 방법을 잘 사용하지 않습니다. 0을 많이 입력하는 게 귀찮기도 하지요. 그래서 대개는 10억(billion)을 나타낼 땐 `'1bn'`을 사용하고, 73억을 나타낼 땐 `'7.3bn'`을 사용합니다. 큰 숫자를 나타낼 땐 이런 방법이 주로 사용되죠.

- 자바스크립트에서도 숫자 옆에 `'e'`를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있습니다.

```jsx
let billion = 1e9;  // 10억, 1과 9개의 0

alert( 7.3e9 );  // 73억 (7,300,000,000)
```

- 즉, 'e'는 e 왼쪽의 수에 e 오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과가 있습니다.

```jsx
1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
```

- 이제 아주 작은 숫자인 1마이크로초(백만 분의 1초)를 표현해보겠습니다.

```jsx
let ms = 0.000001;
```

- 작은 숫자를 표현할 때도 큰 숫자를 표현할 때처럼 'e'를 사용할 수 있습니다. 0을 명시적으로 쓰고 싶지 않다면 다음과 같이 숫자를 표현할 수 있죠.

```jsx
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```

- `0.000001`에서 0의 개수를 세면 6이므로 `0.000001`은 당연히 `1e-6`이 되죠
- 이렇게 `'e'` 우측에 음수가 있으면, 이 음수의 절댓값 만큼 10을 거듭제곱한 수로 나누는 것을 의미합니다.

```jsx
// 10을 세 번 거듭제곱한 수로 나눔
1e-3 = 1 / 1000 (=0.001)

// 10을 여섯 번 거듭제곱한 수로 나눔
1.23e-6 = 1.23 / 1000000 (=0.00000123)
```

> **16진수, 2진수, 8진수**

- 16진수는 색을 나타내거나 문자를 인코딩할 때 등 다양한 곳에서 두루 쓰입니다. 다양한 곳에서 쓰이는 만큼 당연히 16진수를 짧게 표현하는 방법도 존재하겠죠. 16진수는 0x를 사용해 표현할 수 있습니다.

```jsx
alert( 0xff ); // 255
alert( 0xFF ); // 255 (대·소문자를 가리지 않으므로 둘 다 같은 값을 나타냅니다.)
```

- 2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 0b와 0o를 사용해 간단히 나타낼 수 있습니다.

```jsx
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert( a == b ); // true, 진법은 다르지만, a와 b는 같은 수임
```

- 자바스크립트에서 지원하는 진법은 3개입니다. 이 외의 진법을 사용하려면 함수 parseInt를 사용해야 합니다.

> **toString(base)**

- `num.toString(base`) 메서드는 base진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환합니다.

예시 :

```jsx
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base`는 `2`에서 `36`까지 쓸 수 있는데, 기본값은 `10`입니다.

`base`별 유스 케이스는 다음과 같습니다.

- **base=16** – 16진수 색, 문자 인코딩 등을 표현할 때 사용합니다. 숫자는 `0`부터 `9`, 10 이상의 수는 `A`부터 `F`를 사용하여 나타냅니다.
- **base=2** – 비트 연산 디버깅에 주로 쓰입니다. 숫자는 `0` 또는 `1`이 될 수 있습니다.
- **base=36** – 사용할 수 있는 `base` 중 최댓값으로, `0..9`와 `A..Z`를 사용해 숫자를 표현합니다. 알파벳 전체가 숫자를 나타내는 데 사용되죠. `36` 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용합니다. 예시를 살펴봅시다.

```jsx
alert( 123456..toString(36) ); // 2n9c
```

**⚠️  점 두 개와 메서드 호출**

`123456..toString(36)`에 있는 점 두 개는 오타가 아닙니다. 위 예시처럼 숫자를 대상으로 메서드 `toString`을 직접 호출하고 싶다면 숫자 다음에 점 두 개 `..`를 붙여야 합니다.

`123456.toString(36)`처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있습니다. 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출합니다.

`(123456).toString(36)`도 가능합니다.

> **어림수 구하기**

어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나입니다.

어림수 관련 내장 함수 몇 가지를 살펴봅시다.

- **`Math.floor`**소수점 첫째 자리에서 내림(버림).

    `3.1`은 `3`, `-1.1`은 `-2`가 됩니다.

- **`Math.ceil`**소수점 첫째 자리에서 올림.

    `3.1`은 `4`, `-1.1`은 `-1`이 됩니다.

- **`Math.round`**소수점 첫째 자리에서 반올림.

    `3.1`은 `3`, `3.6`은 `4`, `-1.1`은 `-1`이 됩니다.

- **`Math.trunc` (Internet Explorer에서는 지원하지 않음)**소수부를 무시.

    `3.1`은 `3`이 되고 `-1.1`은 `-1`이 됩니다.

- 위에서 소개한 내장 함수들만으로도 소수부에 관련된 연산 대부분을 처리할 수 있습니다. 그런데 소수점 `n-th`번째 수를 기준으로 어림수를 구해야 하는 상황이라면 어떻게 해야 할까요?
- 두 가지 방법이 있습니다.
    1. 곱하기와 나누기
    - 소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 100 또는 100보다 큰 10의 거듭제곱 수를 곱한 후, 원하는 어림수 내장 함수를 호출하고 처음 곱한 수를 다시 나누면 됩니다.

    ```jsx
    let num = 1.23456;

    alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
    ```

    1. 소수점 n 번째 수까지의 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 `toFixed(n)`를 사용합니다.

    ```jsx
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"
    ```

    - `toFixed`는 `Math.round`와 유사하게 가장 가까운 값으로 올림 혹은 버림해줍니다.

    ```jsx
    let num = 12.36;
    alert( num.toFixed(1) ); // "12.4"
    ```

    - `toFixed`를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것입니다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가됩니다.

    ```jsx
    let num = 12.34;
    alert( num.toFixed(5) ); // "12.34000", 소수부의 길이를 5로 만들기 위해 0이 추가되었습니다.
    ```

    - 참고로, `+num.toFixed(5)`처럼 단항 덧셈 연산자를 앞에 붙이거나 `Number()`를 호출하면 문자형의 숫자를 숫자형으로 변환할 수 있습니다.

> **부정확한 계산**

- 숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다. 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용됩니다.
- 그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리됩니다.

```jsx
alert( 1e500 ); // Infinity
```

- 원인을 이해하려면 집중이 필요하긴 하지만, 꽤 자주 발생하는 현상인 **정밀도 손실(loss of precision)**도 있습니다.
- 예시를 살펴봅시다.

```jsx
alert( 0.1 + 0.2 == 0.3 ); // false
```

- `0.1`과 `0.2`의 합이 `0.3`과 일치하는지 확인 했는데 `false`가 출력되었습니다.
- 이상하네요! 합의 결과가 `0.3`이 아니라면 대체 무엇일까요?

```jsx
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

- 부정확한 비교 연산이 만들어내는 결과는 여기서 그치지 않습니다. 인터넷 쇼핑몰 사이트를 운영하고 있다고 가정해 봅시다. 사용자가 `$0.10`와 `$0.20` 짜리 물품을 장바구니에 넣었다고 상상해 보죠. 주문 총액이 `$0.30000000000000004`인 것을 보고 놀라지 않을 사용자는 없을 겁니다.
- 왜 이런 일이 발생하는 걸까요?
- 숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장됩니다. 그런데 10진법을 사용하면 쉽게 표현할 수 있는 `0.1`, `0.2` 같은 분수는 이진법으로 표현하면 무한 소수가 됩니다.
- `0.1`은 1을 10으로 나눈 수인 `1/10`입니다. 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있죠. `1/10`과 `1/3`을 비교해봅시다. `1/3`은 무한 소수 `0.33333(3)`이 됩니다.
- 이렇게 `10`의 거듭제곱으로 나눈 값은 10진법에서 잘 동작하지만 `3`으로 나누게 되면 10진법에서 제대로 동작하지 않습니다. 같은 이유로 2진법 체계에서 `2`의 거듭제곱으로 나눈 값은 잘 동작하지만 `1/10`같이 `2`의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버립니다.
- 10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 *0.1* 또는 *0.2*를 **정확하게** 저장하는 방법은 없습니다.
- IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결합니다. 그런데 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생합니다.
- 아래와 같이 코드를 작성하면 정밀도 손실을 눈으로 확인할 수 있죠.

```jsx
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

- 그리고 두 숫자를 합하면 '정밀도 손실’도 더해집니다.
- `0.1 + 0.2`가 정확히 `0.3`이 아닌 이유가 여기에 있습니다.
- 문제를 해결하는 방법은 없을까요? 물론 있습니다. 가장 신뢰할만한 방법은 `toFixed(n)`메서드를 사용해 어림수를 만드는 것입니다.

```jsx
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

- 이때 `toFixed`는 항상 문자열을 반환한다는 점에 유의해야 합니다. 문자열을 반환하기 때문에 소수점 다음에 오는 숫자가 항상 2개가 될 수 있습니다. 인터넷 쇼핑몰을 구축 중이고 $0.30를 보여줘야 할 때 유용하죠. 문자형으로 바뀐 숫자를 다시 숫자형으로 강제 변환하려면 단항 덧셈 연산자를 사용하면 됩니다.

```jsx
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```